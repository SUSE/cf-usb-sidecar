// This file was generated by counterfeiter
package provisionerfakes

import (
	"sync"

	go_dockerclient "github.com/fsouza/go-dockerclient"
	"github.com/hpcloud/catalog-service-manager/csm-extensions/services/dev-redis/provisioner"
)

type FakeRedisProvisionerInterface struct {
	CreateContainerStub        func(string) error
	createContainerMutex       sync.RWMutex
	createContainerArgsForCall []struct {
		arg1 string
	}
	createContainerReturns struct {
		result1 error
	}
	DeleteContainerStub        func(string) error
	deleteContainerMutex       sync.RWMutex
	deleteContainerArgsForCall []struct {
		arg1 string
	}
	deleteContainerReturns struct {
		result1 error
	}
	ContainerExistsStub        func(string) (bool, error)
	containerExistsMutex       sync.RWMutex
	containerExistsArgsForCall []struct {
		arg1 string
	}
	containerExistsReturns struct {
		result1 bool
		result2 error
	}
	GetCredentialsStub        func(string) (map[string]string, error)
	getCredentialsMutex       sync.RWMutex
	getCredentialsArgsForCall []struct {
		arg1 string
	}
	getCredentialsReturns struct {
		result1 map[string]string
		result2 error
	}
	FindImageStub        func(string) (*go_dockerclient.Image, error)
	findImageMutex       sync.RWMutex
	findImageArgsForCall []struct {
		arg1 string
	}
	findImageReturns struct {
		result1 *go_dockerclient.Image
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRedisProvisionerInterface) CreateContainer(arg1 string) error {
	fake.createContainerMutex.Lock()
	fake.createContainerArgsForCall = append(fake.createContainerArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CreateContainer", []interface{}{arg1})
	fake.createContainerMutex.Unlock()
	if fake.CreateContainerStub != nil {
		return fake.CreateContainerStub(arg1)
	} else {
		return fake.createContainerReturns.result1
	}
}

func (fake *FakeRedisProvisionerInterface) CreateContainerCallCount() int {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	return len(fake.createContainerArgsForCall)
}

func (fake *FakeRedisProvisionerInterface) CreateContainerArgsForCall(i int) string {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	return fake.createContainerArgsForCall[i].arg1
}

func (fake *FakeRedisProvisionerInterface) CreateContainerReturns(result1 error) {
	fake.CreateContainerStub = nil
	fake.createContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRedisProvisionerInterface) DeleteContainer(arg1 string) error {
	fake.deleteContainerMutex.Lock()
	fake.deleteContainerArgsForCall = append(fake.deleteContainerArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteContainer", []interface{}{arg1})
	fake.deleteContainerMutex.Unlock()
	if fake.DeleteContainerStub != nil {
		return fake.DeleteContainerStub(arg1)
	} else {
		return fake.deleteContainerReturns.result1
	}
}

func (fake *FakeRedisProvisionerInterface) DeleteContainerCallCount() int {
	fake.deleteContainerMutex.RLock()
	defer fake.deleteContainerMutex.RUnlock()
	return len(fake.deleteContainerArgsForCall)
}

func (fake *FakeRedisProvisionerInterface) DeleteContainerArgsForCall(i int) string {
	fake.deleteContainerMutex.RLock()
	defer fake.deleteContainerMutex.RUnlock()
	return fake.deleteContainerArgsForCall[i].arg1
}

func (fake *FakeRedisProvisionerInterface) DeleteContainerReturns(result1 error) {
	fake.DeleteContainerStub = nil
	fake.deleteContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRedisProvisionerInterface) ContainerExists(arg1 string) (bool, error) {
	fake.containerExistsMutex.Lock()
	fake.containerExistsArgsForCall = append(fake.containerExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ContainerExists", []interface{}{arg1})
	fake.containerExistsMutex.Unlock()
	if fake.ContainerExistsStub != nil {
		return fake.ContainerExistsStub(arg1)
	} else {
		return fake.containerExistsReturns.result1, fake.containerExistsReturns.result2
	}
}

func (fake *FakeRedisProvisionerInterface) ContainerExistsCallCount() int {
	fake.containerExistsMutex.RLock()
	defer fake.containerExistsMutex.RUnlock()
	return len(fake.containerExistsArgsForCall)
}

func (fake *FakeRedisProvisionerInterface) ContainerExistsArgsForCall(i int) string {
	fake.containerExistsMutex.RLock()
	defer fake.containerExistsMutex.RUnlock()
	return fake.containerExistsArgsForCall[i].arg1
}

func (fake *FakeRedisProvisionerInterface) ContainerExistsReturns(result1 bool, result2 error) {
	fake.ContainerExistsStub = nil
	fake.containerExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeRedisProvisionerInterface) GetCredentials(arg1 string) (map[string]string, error) {
	fake.getCredentialsMutex.Lock()
	fake.getCredentialsArgsForCall = append(fake.getCredentialsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetCredentials", []interface{}{arg1})
	fake.getCredentialsMutex.Unlock()
	if fake.GetCredentialsStub != nil {
		return fake.GetCredentialsStub(arg1)
	} else {
		return fake.getCredentialsReturns.result1, fake.getCredentialsReturns.result2
	}
}

func (fake *FakeRedisProvisionerInterface) GetCredentialsCallCount() int {
	fake.getCredentialsMutex.RLock()
	defer fake.getCredentialsMutex.RUnlock()
	return len(fake.getCredentialsArgsForCall)
}

func (fake *FakeRedisProvisionerInterface) GetCredentialsArgsForCall(i int) string {
	fake.getCredentialsMutex.RLock()
	defer fake.getCredentialsMutex.RUnlock()
	return fake.getCredentialsArgsForCall[i].arg1
}

func (fake *FakeRedisProvisionerInterface) GetCredentialsReturns(result1 map[string]string, result2 error) {
	fake.GetCredentialsStub = nil
	fake.getCredentialsReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeRedisProvisionerInterface) FindImage(arg1 string) (*go_dockerclient.Image, error) {
	fake.findImageMutex.Lock()
	fake.findImageArgsForCall = append(fake.findImageArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindImage", []interface{}{arg1})
	fake.findImageMutex.Unlock()
	if fake.FindImageStub != nil {
		return fake.FindImageStub(arg1)
	} else {
		return fake.findImageReturns.result1, fake.findImageReturns.result2
	}
}

func (fake *FakeRedisProvisionerInterface) FindImageCallCount() int {
	fake.findImageMutex.RLock()
	defer fake.findImageMutex.RUnlock()
	return len(fake.findImageArgsForCall)
}

func (fake *FakeRedisProvisionerInterface) FindImageArgsForCall(i int) string {
	fake.findImageMutex.RLock()
	defer fake.findImageMutex.RUnlock()
	return fake.findImageArgsForCall[i].arg1
}

func (fake *FakeRedisProvisionerInterface) FindImageReturns(result1 *go_dockerclient.Image, result2 error) {
	fake.FindImageStub = nil
	fake.findImageReturns = struct {
		result1 *go_dockerclient.Image
		result2 error
	}{result1, result2}
}

func (fake *FakeRedisProvisionerInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	fake.deleteContainerMutex.RLock()
	defer fake.deleteContainerMutex.RUnlock()
	fake.containerExistsMutex.RLock()
	defer fake.containerExistsMutex.RUnlock()
	fake.getCredentialsMutex.RLock()
	defer fake.getCredentialsMutex.RUnlock()
	fake.findImageMutex.RLock()
	defer fake.findImageMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeRedisProvisionerInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ provisioner.RedisProvisionerInterface = new(FakeRedisProvisionerInterface)
